import { gql } from '@apollo/client';
import * as Apollo from '@apollo/client';
export type Maybe<T> = T | null;
export type InputMaybe<T> = Maybe<T>;
export type Exact<T extends { [key: string]: unknown }> = { [K in keyof T]: T[K] };
export type MakeOptional<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]?: Maybe<T[SubKey]> };
export type MakeMaybe<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]: Maybe<T[SubKey]> };
export type MakeEmpty<T extends { [key: string]: unknown }, K extends keyof T> = { [_ in K]?: never };
export type Incremental<T> = T | { [P in keyof T]?: P extends ' $fragmentName' | '__typename' ? T[P] : never };
const defaultOptions = {} as const;
/** All built-in and custom scalars, mapped to their actual values */
export type Scalars = {
  ID: { input: string; output: string; }
  String: { input: string; output: string; }
  Boolean: { input: boolean; output: boolean; }
  Int: { input: number; output: number; }
  Float: { input: number; output: number; }
  ISO8601Date: { input: any; output: any; }
};

/** Autogenerated input type of AddDish */
export type AddDishInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  dish: DishForCreate;
  dishSource?: InputMaybe<SourceForRead>;
  dishSourceRelationDetail?: InputMaybe<DishSourceRelationDetail>;
  dishTags?: InputMaybe<Array<Tag>>;
};

/** Autogenerated return type of AddDish. */
export type AddDishPayload = {
  __typename?: 'AddDishPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  dishId: Scalars['Int']['output'];
};

/** Autogenerated input type of AddDishWithNewSource */
export type AddDishWithNewSourceInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  dish: DishForCreate;
  dishSource: SourceForCreate;
  dishSourceRelationDetail?: InputMaybe<DishSourceRelationDetail>;
  dishTags?: InputMaybe<Array<Tag>>;
};

/** Autogenerated return type of AddDishWithNewSource. */
export type AddDishWithNewSourcePayload = {
  __typename?: 'AddDishWithNewSourcePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  dishId: Scalars['Int']['output'];
  dishSourceId: Scalars['Int']['output'];
};

/** Autogenerated input type of AddMeal */
export type AddMealInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  dishId: Scalars['Int']['input'];
  meal: MealForCreate;
};

/** Autogenerated return type of AddMeal. */
export type AddMealPayload = {
  __typename?: 'AddMealPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  mealId: Scalars['Int']['output'];
};

/** Autogenerated input type of AddMealWithNewDishAndNewSource */
export type AddMealWithNewDishAndNewSourceInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  dish: DishForCreate;
  dishSource: SourceForCreate;
  dishSourceRelationDetail?: InputMaybe<DishSourceRelationDetail>;
  dishTags?: InputMaybe<Array<Tag>>;
  meal: MealForCreate;
};

/** Autogenerated return type of AddMealWithNewDishAndNewSource. */
export type AddMealWithNewDishAndNewSourcePayload = {
  __typename?: 'AddMealWithNewDishAndNewSourcePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  dishId: Scalars['Int']['output'];
  dishSourceId: Scalars['Int']['output'];
  mealId: Scalars['Int']['output'];
};

/** Autogenerated input type of AddMealWithNewDish */
export type AddMealWithNewDishInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  dish: DishForCreate;
  dishSource?: InputMaybe<SourceForRead>;
  dishSourceRelationDetail?: InputMaybe<DishSourceRelationDetail>;
  dishTags?: InputMaybe<Array<Tag>>;
  meal: MealForCreate;
};

/** Autogenerated return type of AddMealWithNewDish. */
export type AddMealWithNewDishPayload = {
  __typename?: 'AddMealWithNewDishPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  dishId: Scalars['Int']['output'];
  mealId: Scalars['Int']['output'];
};

/** Autogenerated input type of AddSource */
export type AddSourceInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  dishSource: SourceForCreate;
};

/** Autogenerated return type of AddSource. */
export type AddSourcePayload = {
  __typename?: 'AddSourcePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  dishSourceId: Scalars['Int']['output'];
};

export type Authenticatable = {
  __typename?: 'Authenticatable';
  email: Scalars['String']['output'];
};

export type Credential = {
  __typename?: 'Credential';
  accessToken: Scalars['String']['output'];
  client: Scalars['String']['output'];
  expiry: Scalars['Int']['output'];
  tokenType: Scalars['String']['output'];
  uid: Scalars['String']['output'];
};

export type Dish = DishFields & {
  __typename?: 'Dish';
  comment?: Maybe<Scalars['String']['output']>;
  dishSourceRelation?: Maybe<DishSourceRelation>;
  evaluationScore?: Maybe<Scalars['Float']['output']>;
  id: Scalars['Int']['output'];
  mealPosition: Scalars['Int']['output'];
  name: Scalars['String']['output'];
  tags?: Maybe<Array<DishTag>>;
};

export type DishFields = {
  comment?: Maybe<Scalars['String']['output']>;
  dishSourceRelation?: Maybe<DishSourceRelation>;
  evaluationScore?: Maybe<Scalars['Float']['output']>;
  id: Scalars['Int']['output'];
  mealPosition: Scalars['Int']['output'];
  name: Scalars['String']['output'];
  tags?: Maybe<Array<DishTag>>;
};

export type DishForCreate = {
  comment?: InputMaybe<Scalars['String']['input']>;
  mealPosition: Scalars['Int']['input'];
  name: Scalars['String']['input'];
};

export type DishForUpdate = {
  comment?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
  mealPosition?: InputMaybe<Scalars['Int']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
};

export type DishSource = DishSourceFields & {
  __typename?: 'DishSource';
  id: Scalars['Int']['output'];
  name: Scalars['String']['output'];
  type: Scalars['Int']['output'];
};

export type DishSourceFields = {
  id: Scalars['Int']['output'];
  name: Scalars['String']['output'];
  type: Scalars['Int']['output'];
};

export type DishSourceRegisteredWithDish = DishSourceFields & {
  __typename?: 'DishSourceRegisteredWithDish';
  id: Scalars['Int']['output'];
  name: Scalars['String']['output'];
  type: Scalars['Int']['output'];
};

export type DishSourceRelation = {
  __typename?: 'DishSourceRelation';
  dishId: Scalars['Int']['output'];
  dishSourceId: Scalars['Int']['output'];
  recipeBookPage?: Maybe<Scalars['Int']['output']>;
  recipeSourceMemo?: Maybe<Scalars['String']['output']>;
  recipeWebsiteUrl?: Maybe<Scalars['String']['output']>;
  sourceName?: Maybe<Scalars['String']['output']>;
  type: Scalars['Int']['output'];
};

export type DishSourceRelationDetail = {
  recipeBookPage?: InputMaybe<Scalars['Int']['input']>;
  recipeSourceMemo?: InputMaybe<Scalars['String']['input']>;
  recipeWebsiteUrl?: InputMaybe<Scalars['String']['input']>;
};

export type DishSourceRelationForUpdate = {
  dishId: Scalars['Int']['input'];
  dishSourceId: Scalars['Int']['input'];
  dishSourceRelationDetail: DishSourceRelationDetail;
  dishSourceType: Scalars['Int']['input'];
};

export type DishTag = {
  __typename?: 'DishTag';
  content: Scalars['String']['output'];
  dishId: Scalars['Int']['output'];
  id: Scalars['Int']['output'];
};

export type DishWithRegisteredMeals = DishFields & {
  __typename?: 'DishWithRegisteredMeals';
  comment?: Maybe<Scalars['String']['output']>;
  dishSourceRelation?: Maybe<DishSourceRelation>;
  evaluationScore?: Maybe<Scalars['Float']['output']>;
  id: Scalars['Int']['output'];
  mealPosition: Scalars['Int']['output'];
  meals: Array<Meal>;
  name: Scalars['String']['output'];
  tags?: Maybe<Array<DishTag>>;
};

export type DishesForDisplayWithSource = {
  __typename?: 'DishesForDisplayWithSource';
  dishSource?: Maybe<DishSource>;
  dishesPerMealPosition: Array<DishesPerMealPosition>;
};

export type DishesPerMealPosition = {
  __typename?: 'DishesPerMealPosition';
  dishes: Array<DishWithRegisteredMeals>;
  mealPosition?: Maybe<Scalars['Int']['output']>;
};

/** Autogenerated input type of EvaluateDish */
export type EvaluateDishInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  dishId: Scalars['Int']['input'];
  score: Scalars['Float']['input'];
};

/** Autogenerated return type of EvaluateDish. */
export type EvaluateDishPayload = {
  __typename?: 'EvaluateDishPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  dishId: Scalars['Int']['output'];
};

export type ExistingDishForRegisteringWithMeal = DishFields & {
  __typename?: 'ExistingDishForRegisteringWithMeal';
  comment?: Maybe<Scalars['String']['output']>;
  dishSourceName?: Maybe<Scalars['String']['output']>;
  dishSourceRelation?: Maybe<DishSourceRelation>;
  evaluationScore?: Maybe<Scalars['Float']['output']>;
  id: Scalars['Int']['output'];
  mealPosition: Scalars['Int']['output'];
  name: Scalars['String']['output'];
  tags?: Maybe<Array<DishTag>>;
};

/** Autogenerated return type of LoginUserConfirmRegistrationWithToken. */
export type LoginUserConfirmRegistrationWithTokenPayload = {
  __typename?: 'LoginUserConfirmRegistrationWithTokenPayload';
  authenticatable: Authenticatable;
  /** Authentication credentials. Null unless user is signed in after confirmation. */
  credentials?: Maybe<Credential>;
};

/** Autogenerated return type of LoginUserLogin. */
export type LoginUserLoginPayload = {
  __typename?: 'LoginUserLoginPayload';
  authenticatable: Authenticatable;
  credentials: Credential;
};

/** Autogenerated return type of LoginUserLogout. */
export type LoginUserLogoutPayload = {
  __typename?: 'LoginUserLogoutPayload';
  authenticatable: Authenticatable;
};

/** Autogenerated return type of LoginUserRegister. */
export type LoginUserRegisterPayload = {
  __typename?: 'LoginUserRegisterPayload';
  /** Authentication credentials. Null if after signUp resource is not active for authentication (e.g. Email confirmation required). */
  credentials?: Maybe<Credential>;
};

/** Autogenerated return type of LoginUserResendConfirmationWithToken. */
export type LoginUserResendConfirmationWithTokenPayload = {
  __typename?: 'LoginUserResendConfirmationWithTokenPayload';
  message: Scalars['String']['output'];
};

/** Autogenerated return type of LoginUserSendPasswordResetWithToken. */
export type LoginUserSendPasswordResetWithTokenPayload = {
  __typename?: 'LoginUserSendPasswordResetWithTokenPayload';
  message: Scalars['String']['output'];
};

/** Autogenerated return type of LoginUserUpdatePasswordWithToken. */
export type LoginUserUpdatePasswordWithTokenPayload = {
  __typename?: 'LoginUserUpdatePasswordWithTokenPayload';
  authenticatable: Authenticatable;
  /** Authentication credentials. Resource must be signed_in for credentials to be returned. */
  credentials?: Maybe<Credential>;
};

export type Meal = MealFields & {
  __typename?: 'Meal';
  comment?: Maybe<Scalars['String']['output']>;
  date: Scalars['ISO8601Date']['output'];
  dish: Dish;
  id: Scalars['Int']['output'];
  mealType: Scalars['Int']['output'];
};

export type MealFields = {
  comment?: Maybe<Scalars['String']['output']>;
  date: Scalars['ISO8601Date']['output'];
  dish: Dish;
  id: Scalars['Int']['output'];
  mealType: Scalars['Int']['output'];
};

export type MealForCalender = MealFields & {
  __typename?: 'MealForCalender';
  comment?: Maybe<Scalars['String']['output']>;
  date: Scalars['ISO8601Date']['output'];
  dish: Dish;
  id: Scalars['Int']['output'];
  mealType: Scalars['Int']['output'];
};

export type MealForCreate = {
  comment?: InputMaybe<Scalars['String']['input']>;
  date: Scalars['ISO8601Date']['input'];
  mealType: Scalars['Int']['input'];
};

export type MealForUpdate = {
  comment?: InputMaybe<Scalars['String']['input']>;
  date?: InputMaybe<Scalars['ISO8601Date']['input']>;
  id: Scalars['Int']['input'];
  mealType?: InputMaybe<Scalars['Int']['input']>;
};

export type MealsOfDate = {
  __typename?: 'MealsOfDate';
  date: Scalars['ISO8601Date']['output'];
  meals: Array<MealForCalender>;
};

export type Mutation = {
  __typename?: 'Mutation';
  addDish?: Maybe<AddDishPayload>;
  addDishSource?: Maybe<AddSourcePayload>;
  addDishWithNewSource?: Maybe<AddDishWithNewSourcePayload>;
  addMeal?: Maybe<AddMealPayload>;
  addMealWithNewDish?: Maybe<AddMealWithNewDishPayload>;
  addMealWithNewDishAndNewSource?: Maybe<AddMealWithNewDishAndNewSourcePayload>;
  evaluateDish?: Maybe<EvaluateDishPayload>;
  loginUserConfirmRegistrationWithToken?: Maybe<LoginUserConfirmRegistrationWithTokenPayload>;
  loginUserLogin?: Maybe<LoginUserLoginPayload>;
  loginUserLogout?: Maybe<LoginUserLogoutPayload>;
  loginUserRegister?: Maybe<LoginUserRegisterPayload>;
  loginUserResendConfirmationWithToken?: Maybe<LoginUserResendConfirmationWithTokenPayload>;
  loginUserSendPasswordResetWithToken?: Maybe<LoginUserSendPasswordResetWithTokenPayload>;
  loginUserUpdatePasswordWithToken?: Maybe<LoginUserUpdatePasswordWithTokenPayload>;
  removeDish?: Maybe<RemoveDishPayload>;
  removeDishSource?: Maybe<RemoveSourcePayload>;
  removeMeal?: Maybe<RemoveMealPayload>;
  swapMealsBetweenDays?: Maybe<SwapMealsBetweenDaysPayload>;
  updateDish?: Maybe<UpdateDishPayload>;
  updateDishSource?: Maybe<UpdateSourcePayload>;
  updateDishWithNewSource?: Maybe<UpdateDishWithNewSourcePayload>;
  updateMeal?: Maybe<UpdateMealPayload>;
  updateMealWithNewDish?: Maybe<UpdateMealWithNewDishPayload>;
  updateMealWithNewDishAndNewSource?: Maybe<UpdateMealWithNewDishAndNewSourcePayload>;
};


export type MutationAddDishArgs = {
  input: AddDishInput;
};


export type MutationAddDishSourceArgs = {
  input: AddSourceInput;
};


export type MutationAddDishWithNewSourceArgs = {
  input: AddDishWithNewSourceInput;
};


export type MutationAddMealArgs = {
  input: AddMealInput;
};


export type MutationAddMealWithNewDishArgs = {
  input: AddMealWithNewDishInput;
};


export type MutationAddMealWithNewDishAndNewSourceArgs = {
  input: AddMealWithNewDishAndNewSourceInput;
};


export type MutationEvaluateDishArgs = {
  input: EvaluateDishInput;
};


export type MutationLoginUserConfirmRegistrationWithTokenArgs = {
  confirmationToken: Scalars['String']['input'];
};


export type MutationLoginUserLoginArgs = {
  email: Scalars['String']['input'];
  password: Scalars['String']['input'];
};


export type MutationLoginUserRegisterArgs = {
  confirmUrl?: InputMaybe<Scalars['String']['input']>;
  email: Scalars['String']['input'];
  password: Scalars['String']['input'];
  passwordConfirmation: Scalars['String']['input'];
};


export type MutationLoginUserResendConfirmationWithTokenArgs = {
  confirmUrl: Scalars['String']['input'];
  email: Scalars['String']['input'];
};


export type MutationLoginUserSendPasswordResetWithTokenArgs = {
  email: Scalars['String']['input'];
  redirectUrl: Scalars['String']['input'];
};


export type MutationLoginUserUpdatePasswordWithTokenArgs = {
  password: Scalars['String']['input'];
  passwordConfirmation: Scalars['String']['input'];
  resetPasswordToken: Scalars['String']['input'];
};


export type MutationRemoveDishArgs = {
  input: RemoveDishInput;
};


export type MutationRemoveDishSourceArgs = {
  input: RemoveSourceInput;
};


export type MutationRemoveMealArgs = {
  input: RemoveMealInput;
};


export type MutationSwapMealsBetweenDaysArgs = {
  input: SwapMealsBetweenDaysInput;
};


export type MutationUpdateDishArgs = {
  input: UpdateDishInput;
};


export type MutationUpdateDishSourceArgs = {
  input: UpdateSourceInput;
};


export type MutationUpdateDishWithNewSourceArgs = {
  input: UpdateDishWithNewSourceInput;
};


export type MutationUpdateMealArgs = {
  input: UpdateMealInput;
};


export type MutationUpdateMealWithNewDishArgs = {
  input: UpdateMealWithNewDishInput;
};


export type MutationUpdateMealWithNewDishAndNewSourceArgs = {
  input: UpdateMealWithNewDishAndNewSourceInput;
};

export type Query = {
  __typename?: 'Query';
  dish: SpecifiedDish;
  dishSource: SpecifiedDishSource;
  dishSources: Array<DishSourceRegisteredWithDish>;
  dishesPerSource: Array<DishesForDisplayWithSource>;
  existingDishesForRegisteringWithMeal: Array<ExistingDishForRegisteringWithMeal>;
  mealsForCalender: Array<MealsOfDate>;
  /** An example field added by the generator */
  testField: Scalars['String']['output'];
};


export type QueryDishArgs = {
  id: Scalars['Int']['input'];
};


export type QueryDishSourceArgs = {
  id: Scalars['Int']['input'];
};


export type QueryExistingDishesForRegisteringWithMealArgs = {
  dishIdRegisteredWithMeal?: InputMaybe<Scalars['Int']['input']>;
  mealPosition?: InputMaybe<Scalars['Int']['input']>;
  registeredWithMeal?: InputMaybe<Scalars['Boolean']['input']>;
  searchString?: InputMaybe<Scalars['String']['input']>;
};


export type QueryMealsForCalenderArgs = {
  startDate: Scalars['ISO8601Date']['input'];
};

/** Autogenerated input type of RemoveDish */
export type RemoveDishInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  dishId: Scalars['Int']['input'];
};

/** Autogenerated return type of RemoveDish. */
export type RemoveDishPayload = {
  __typename?: 'RemoveDishPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  dishId: Scalars['Int']['output'];
};

/** Autogenerated input type of RemoveMeal */
export type RemoveMealInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  mealId: Scalars['Int']['input'];
};

/** Autogenerated return type of RemoveMeal. */
export type RemoveMealPayload = {
  __typename?: 'RemoveMealPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  mealId: Scalars['Int']['output'];
};

/** Autogenerated input type of RemoveSource */
export type RemoveSourceInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  dishSourceId: Scalars['Int']['input'];
};

/** Autogenerated return type of RemoveSource. */
export type RemoveSourcePayload = {
  __typename?: 'RemoveSourcePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  dishSourceId: Scalars['Int']['output'];
};

export type SourceForCreate = {
  comment?: InputMaybe<Scalars['String']['input']>;
  name: Scalars['String']['input'];
  type: Scalars['Int']['input'];
};

export type SourceForRead = {
  comment?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
  name?: InputMaybe<Scalars['String']['input']>;
  type?: InputMaybe<Scalars['Int']['input']>;
};

export type SourceForUpdate = {
  comment?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
  name?: InputMaybe<Scalars['String']['input']>;
  type?: InputMaybe<Scalars['Int']['input']>;
};

export type SpecifiedDish = DishFields & {
  __typename?: 'SpecifiedDish';
  comment?: Maybe<Scalars['String']['output']>;
  dishSourceRelation?: Maybe<DishSourceRelation>;
  evaluationScore?: Maybe<Scalars['Float']['output']>;
  id: Scalars['Int']['output'];
  mealPosition: Scalars['Int']['output'];
  name: Scalars['String']['output'];
  tags?: Maybe<Array<DishTag>>;
};

export type SpecifiedDishSource = DishSourceFields & {
  __typename?: 'SpecifiedDishSource';
  id: Scalars['Int']['output'];
  name: Scalars['String']['output'];
  type: Scalars['Int']['output'];
};

/** Autogenerated input type of SwapMealsBetweenDays */
export type SwapMealsBetweenDaysInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  date1: Scalars['ISO8601Date']['input'];
  date2: Scalars['ISO8601Date']['input'];
};

/** Autogenerated return type of SwapMealsBetweenDays. */
export type SwapMealsBetweenDaysPayload = {
  __typename?: 'SwapMealsBetweenDaysPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  updatedMealIds?: Maybe<Array<Scalars['Int']['output']>>;
};

export type Tag = {
  content: Scalars['String']['input'];
  id?: InputMaybe<Scalars['Int']['input']>;
};

/** Autogenerated input type of UpdateDish */
export type UpdateDishInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  dish: DishForUpdate;
  dishSourceRelation?: InputMaybe<DishSourceRelationForUpdate>;
  dishTags?: InputMaybe<Array<Tag>>;
};

/** Autogenerated return type of UpdateDish. */
export type UpdateDishPayload = {
  __typename?: 'UpdateDishPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  dishId: Scalars['Int']['output'];
};

/** Autogenerated input type of UpdateDishWithNewSource */
export type UpdateDishWithNewSourceInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  dish: DishForUpdate;
  dishSource: SourceForCreate;
  dishSourceRelationDetail?: InputMaybe<DishSourceRelationDetail>;
  dishTags?: InputMaybe<Array<Tag>>;
};

/** Autogenerated return type of UpdateDishWithNewSource. */
export type UpdateDishWithNewSourcePayload = {
  __typename?: 'UpdateDishWithNewSourcePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  dishId: Scalars['Int']['output'];
};

/** Autogenerated input type of UpdateMeal */
export type UpdateMealInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  dishId: Scalars['Int']['input'];
  meal: MealForUpdate;
};

/** Autogenerated return type of UpdateMeal. */
export type UpdateMealPayload = {
  __typename?: 'UpdateMealPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  mealId: Scalars['Int']['output'];
};

/** Autogenerated input type of UpdateMealWithNewDishAndNewSource */
export type UpdateMealWithNewDishAndNewSourceInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  dish: DishForCreate;
  dishSource: SourceForCreate;
  dishSourceRelationDetail?: InputMaybe<DishSourceRelationDetail>;
  dishTags?: InputMaybe<Array<Tag>>;
  meal: MealForUpdate;
};

/** Autogenerated return type of UpdateMealWithNewDishAndNewSource. */
export type UpdateMealWithNewDishAndNewSourcePayload = {
  __typename?: 'UpdateMealWithNewDishAndNewSourcePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  dishId: Scalars['Int']['output'];
  dishSourceId: Scalars['Int']['output'];
  mealId: Scalars['Int']['output'];
};

/** Autogenerated input type of UpdateMealWithNewDish */
export type UpdateMealWithNewDishInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  dish: DishForCreate;
  dishSource: SourceForRead;
  dishSourceRelationDetail?: InputMaybe<DishSourceRelationDetail>;
  dishTags?: InputMaybe<Array<Tag>>;
  meal: MealForUpdate;
};

/** Autogenerated return type of UpdateMealWithNewDish. */
export type UpdateMealWithNewDishPayload = {
  __typename?: 'UpdateMealWithNewDishPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  dishId: Scalars['Int']['output'];
  mealId: Scalars['Int']['output'];
};

/** Autogenerated input type of UpdateSource */
export type UpdateSourceInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  dishSource: SourceForUpdate;
};

/** Autogenerated return type of UpdateSource. */
export type UpdateSourcePayload = {
  __typename?: 'UpdateSourcePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  dishSourceId: Scalars['Int']['output'];
};

export type LoginMutationVariables = Exact<{
  email: Scalars['String']['input'];
  password: Scalars['String']['input'];
}>;


export type LoginMutation = { __typename?: 'Mutation', loginUserLogin?: { __typename?: 'LoginUserLoginPayload', credentials: { __typename?: 'Credential', uid: string } } | null };

export type SignupMutationVariables = Exact<{
  email: Scalars['String']['input'];
  password: Scalars['String']['input'];
  passwordConfirmation: Scalars['String']['input'];
}>;


export type SignupMutation = { __typename?: 'Mutation', loginUserRegister?: { __typename?: 'LoginUserRegisterPayload', credentials?: { __typename?: 'Credential', accessToken: string } | null } | null };

export type AddDishMutationVariables = Exact<{
  dish: DishForCreate;
  dishSource?: InputMaybe<SourceForRead>;
  dishSourceRelationDetail?: InputMaybe<DishSourceRelationDetail>;
  dishTags?: InputMaybe<Array<Tag> | Tag>;
}>;


export type AddDishMutation = { __typename?: 'Mutation', addDish?: { __typename?: 'AddDishPayload', dishId: number } | null };

export type AddDishWithNewSourceMutationVariables = Exact<{
  dish: DishForCreate;
  dishSource: SourceForCreate;
  dishSourceRelationDetail?: InputMaybe<DishSourceRelationDetail>;
  dishTags?: InputMaybe<Array<Tag> | Tag>;
}>;


export type AddDishWithNewSourceMutation = { __typename?: 'Mutation', addDishWithNewSource?: { __typename?: 'AddDishWithNewSourcePayload', dishId: number, dishSourceId: number } | null };

export type ExistingDishesForRegisteringWithMealQueryVariables = Exact<{
  dishIdRegisteredWithMeal?: InputMaybe<Scalars['Int']['input']>;
  searchString?: InputMaybe<Scalars['String']['input']>;
  mealPosition?: InputMaybe<Scalars['Int']['input']>;
  registeredWithMeal?: InputMaybe<Scalars['Boolean']['input']>;
}>;


export type ExistingDishesForRegisteringWithMealQuery = { __typename?: 'Query', existingDishesForRegisteringWithMeal: Array<{ __typename?: 'ExistingDishForRegisteringWithMeal', id: number, name: string, mealPosition: number, comment?: string | null, dishSourceName?: string | null }> };

export type DishQueryVariables = Exact<{
  id: Scalars['Int']['input'];
}>;


export type DishQuery = { __typename?: 'Query', dish: { __typename?: 'SpecifiedDish', id: number, name: string, mealPosition: number, comment?: string | null, dishSourceRelation?: { __typename?: 'DishSourceRelation', dishSourceId: number, recipeBookPage?: number | null, recipeWebsiteUrl?: string | null, recipeSourceMemo?: string | null } | null, tags?: Array<{ __typename?: 'DishTag', id: number, content: string }> | null } };

export type DishesPerSourceQueryVariables = Exact<{ [key: string]: never; }>;


export type DishesPerSourceQuery = { __typename?: 'Query', dishesPerSource: Array<{ __typename?: 'DishesForDisplayWithSource', dishSource?: { __typename?: 'DishSource', id: number, name: string, type: number } | null, dishesPerMealPosition: Array<{ __typename?: 'DishesPerMealPosition', mealPosition?: number | null, dishes: Array<{ __typename?: 'DishWithRegisteredMeals', id: number, name: string, mealPosition: number, comment?: string | null, meals: Array<{ __typename?: 'Meal', id: number }> }> }> }> };

export type RemoveDishMutationVariables = Exact<{
  dishId: Scalars['Int']['input'];
}>;


export type RemoveDishMutation = { __typename?: 'Mutation', removeDish?: { __typename?: 'RemoveDishPayload', dishId: number } | null };

export type AddDishSourceMutationVariables = Exact<{
  dishSource: SourceForCreate;
}>;


export type AddDishSourceMutation = { __typename?: 'Mutation', addDishSource?: { __typename?: 'AddSourcePayload', dishSourceId: number } | null };

export type DishSourcesQueryVariables = Exact<{ [key: string]: never; }>;


export type DishSourcesQuery = { __typename?: 'Query', dishSources: Array<{ __typename?: 'DishSourceRegisteredWithDish', id: number, name: string, type: number }> };

export type DishSourceQueryVariables = Exact<{
  id: Scalars['Int']['input'];
}>;


export type DishSourceQuery = { __typename?: 'Query', dishSource: { __typename?: 'SpecifiedDishSource', id: number, name: string, type: number } };

export type RemoveDishSourceMutationVariables = Exact<{
  dishSourceId: Scalars['Int']['input'];
}>;


export type RemoveDishSourceMutation = { __typename?: 'Mutation', removeDishSource?: { __typename?: 'RemoveSourcePayload', dishSourceId: number } | null };

export type UpdateDishSourceMutationVariables = Exact<{
  dishSource: SourceForUpdate;
}>;


export type UpdateDishSourceMutation = { __typename?: 'Mutation', updateDishSource?: { __typename?: 'UpdateSourcePayload', dishSourceId: number } | null };

export type UpdateDishMutationVariables = Exact<{
  dish: DishForUpdate;
  dishSourceRelation?: InputMaybe<DishSourceRelationForUpdate>;
  dishTags?: InputMaybe<Array<Tag> | Tag>;
}>;


export type UpdateDishMutation = { __typename?: 'Mutation', updateDish?: { __typename?: 'UpdateDishPayload', dishId: number } | null };

export type UpdateDishWithNewSourceMutationVariables = Exact<{
  dish: DishForUpdate;
  dishSource: SourceForCreate;
  dishSourceRelationDetail?: InputMaybe<DishSourceRelationDetail>;
  dishTags?: InputMaybe<Array<Tag> | Tag>;
}>;


export type UpdateDishWithNewSourceMutation = { __typename?: 'Mutation', updateDishWithNewSource?: { __typename?: 'UpdateDishWithNewSourcePayload', dishId: number } | null };

export type EvaluateDishMutationVariables = Exact<{
  dishId: Scalars['Int']['input'];
  score: Scalars['Float']['input'];
}>;


export type EvaluateDishMutation = { __typename?: 'Mutation', evaluateDish?: { __typename?: 'EvaluateDishPayload', dishId: number } | null };

export type AddMealMutationVariables = Exact<{
  dishId: Scalars['Int']['input'];
  meal: MealForCreate;
}>;


export type AddMealMutation = { __typename?: 'Mutation', addMeal?: { __typename?: 'AddMealPayload', mealId: number } | null };

export type AddMealWithNewDishMutationVariables = Exact<{
  dish: DishForCreate;
  dishSource?: InputMaybe<SourceForRead>;
  dishSourceRelationDetail?: InputMaybe<DishSourceRelationDetail>;
  dishTags?: InputMaybe<Array<Tag> | Tag>;
  meal: MealForCreate;
}>;


export type AddMealWithNewDishMutation = { __typename?: 'Mutation', addMealWithNewDish?: { __typename?: 'AddMealWithNewDishPayload', mealId: number, dishId: number } | null };

export type AddMealWithNewDishAndNewSourceMutationVariables = Exact<{
  dish: DishForCreate;
  dishSource: SourceForCreate;
  dishSourceRelationDetail?: InputMaybe<DishSourceRelationDetail>;
  dishTags?: InputMaybe<Array<Tag> | Tag>;
  meal: MealForCreate;
}>;


export type AddMealWithNewDishAndNewSourceMutation = { __typename?: 'Mutation', addMealWithNewDishAndNewSource?: { __typename?: 'AddMealWithNewDishAndNewSourcePayload', mealId: number, dishId: number, dishSourceId: number } | null };

export type MealsForCalenderQueryVariables = Exact<{
  startDate: Scalars['ISO8601Date']['input'];
}>;


export type MealsForCalenderQuery = { __typename?: 'Query', mealsForCalender: Array<{ __typename?: 'MealsOfDate', date: any, meals: Array<{ __typename?: 'MealForCalender', id: number, date: any, mealType: number, comment?: string | null, dish: { __typename?: 'Dish', id: number, name: string, mealPosition: number, comment?: string | null, evaluationScore?: number | null, dishSourceRelation?: { __typename?: 'DishSourceRelation', type: number, sourceName?: string | null, dishSourceId: number, recipeBookPage?: number | null, recipeWebsiteUrl?: string | null, recipeSourceMemo?: string | null } | null, tags?: Array<{ __typename?: 'DishTag', id: number, dishId: number, content: string }> | null } }> }> };

export type RemoveMealMutationVariables = Exact<{
  mealId: Scalars['Int']['input'];
}>;


export type RemoveMealMutation = { __typename?: 'Mutation', removeMeal?: { __typename?: 'RemoveMealPayload', mealId: number } | null };

export type SwapMealsBetweenDaysMutationVariables = Exact<{
  date1: Scalars['ISO8601Date']['input'];
  date2: Scalars['ISO8601Date']['input'];
}>;


export type SwapMealsBetweenDaysMutation = { __typename?: 'Mutation', swapMealsBetweenDays?: { __typename?: 'SwapMealsBetweenDaysPayload', updatedMealIds?: Array<number> | null } | null };

export type UpdateMealMutationVariables = Exact<{
  dishId: Scalars['Int']['input'];
  meal: MealForUpdate;
}>;


export type UpdateMealMutation = { __typename?: 'Mutation', updateMeal?: { __typename?: 'UpdateMealPayload', mealId: number } | null };

export type UpdateMealWithNewDishMutationVariables = Exact<{
  dish: DishForCreate;
  dishSource: SourceForRead;
  dishSourceRelationDetail?: InputMaybe<DishSourceRelationDetail>;
  dishTags?: InputMaybe<Array<Tag> | Tag>;
  meal: MealForUpdate;
}>;


export type UpdateMealWithNewDishMutation = { __typename?: 'Mutation', updateMealWithNewDish?: { __typename?: 'UpdateMealWithNewDishPayload', mealId: number, dishId: number } | null };

export type UpdateMealWithNewDishAndNewSourceMutationVariables = Exact<{
  dish: DishForCreate;
  dishSource: SourceForCreate;
  dishSourceRelationDetail?: InputMaybe<DishSourceRelationDetail>;
  dishTags?: InputMaybe<Array<Tag> | Tag>;
  meal: MealForUpdate;
}>;


export type UpdateMealWithNewDishAndNewSourceMutation = { __typename?: 'Mutation', updateMealWithNewDishAndNewSource?: { __typename?: 'UpdateMealWithNewDishAndNewSourcePayload', mealId: number, dishId: number, dishSourceId: number } | null };


export const LoginDocument = gql`
    mutation login($email: String!, $password: String!) {
  loginUserLogin(email: $email, password: $password) {
    credentials {
      uid
    }
  }
}
    `;
export type LoginMutationFn = Apollo.MutationFunction<LoginMutation, LoginMutationVariables>;

/**
 * __useLoginMutation__
 *
 * To run a mutation, you first call `useLoginMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useLoginMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [loginMutation, { data, loading, error }] = useLoginMutation({
 *   variables: {
 *      email: // value for 'email'
 *      password: // value for 'password'
 *   },
 * });
 */
export function useLoginMutation(baseOptions?: Apollo.MutationHookOptions<LoginMutation, LoginMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<LoginMutation, LoginMutationVariables>(LoginDocument, options);
      }
export type LoginMutationHookResult = ReturnType<typeof useLoginMutation>;
export type LoginMutationResult = Apollo.MutationResult<LoginMutation>;
export type LoginMutationOptions = Apollo.BaseMutationOptions<LoginMutation, LoginMutationVariables>;
export const SignupDocument = gql`
    mutation signup($email: String!, $password: String!, $passwordConfirmation: String!) {
  loginUserRegister(
    email: $email
    password: $password
    passwordConfirmation: $passwordConfirmation
  ) {
    credentials {
      accessToken
    }
  }
}
    `;
export type SignupMutationFn = Apollo.MutationFunction<SignupMutation, SignupMutationVariables>;

/**
 * __useSignupMutation__
 *
 * To run a mutation, you first call `useSignupMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useSignupMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [signupMutation, { data, loading, error }] = useSignupMutation({
 *   variables: {
 *      email: // value for 'email'
 *      password: // value for 'password'
 *      passwordConfirmation: // value for 'passwordConfirmation'
 *   },
 * });
 */
export function useSignupMutation(baseOptions?: Apollo.MutationHookOptions<SignupMutation, SignupMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<SignupMutation, SignupMutationVariables>(SignupDocument, options);
      }
export type SignupMutationHookResult = ReturnType<typeof useSignupMutation>;
export type SignupMutationResult = Apollo.MutationResult<SignupMutation>;
export type SignupMutationOptions = Apollo.BaseMutationOptions<SignupMutation, SignupMutationVariables>;
export const AddDishDocument = gql`
    mutation addDish($dish: DishForCreate!, $dishSource: SourceForRead, $dishSourceRelationDetail: DishSourceRelationDetail, $dishTags: [Tag!]) {
  addDish(
    input: {dish: $dish, dishSource: $dishSource, dishSourceRelationDetail: $dishSourceRelationDetail, dishTags: $dishTags}
  ) {
    dishId
  }
}
    `;
export type AddDishMutationFn = Apollo.MutationFunction<AddDishMutation, AddDishMutationVariables>;

/**
 * __useAddDishMutation__
 *
 * To run a mutation, you first call `useAddDishMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useAddDishMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [addDishMutation, { data, loading, error }] = useAddDishMutation({
 *   variables: {
 *      dish: // value for 'dish'
 *      dishSource: // value for 'dishSource'
 *      dishSourceRelationDetail: // value for 'dishSourceRelationDetail'
 *      dishTags: // value for 'dishTags'
 *   },
 * });
 */
export function useAddDishMutation(baseOptions?: Apollo.MutationHookOptions<AddDishMutation, AddDishMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<AddDishMutation, AddDishMutationVariables>(AddDishDocument, options);
      }
export type AddDishMutationHookResult = ReturnType<typeof useAddDishMutation>;
export type AddDishMutationResult = Apollo.MutationResult<AddDishMutation>;
export type AddDishMutationOptions = Apollo.BaseMutationOptions<AddDishMutation, AddDishMutationVariables>;
export const AddDishWithNewSourceDocument = gql`
    mutation addDishWithNewSource($dish: DishForCreate!, $dishSource: SourceForCreate!, $dishSourceRelationDetail: DishSourceRelationDetail, $dishTags: [Tag!]) {
  addDishWithNewSource(
    input: {dish: $dish, dishSource: $dishSource, dishSourceRelationDetail: $dishSourceRelationDetail, dishTags: $dishTags}
  ) {
    dishId
    dishSourceId
  }
}
    `;
export type AddDishWithNewSourceMutationFn = Apollo.MutationFunction<AddDishWithNewSourceMutation, AddDishWithNewSourceMutationVariables>;

/**
 * __useAddDishWithNewSourceMutation__
 *
 * To run a mutation, you first call `useAddDishWithNewSourceMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useAddDishWithNewSourceMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [addDishWithNewSourceMutation, { data, loading, error }] = useAddDishWithNewSourceMutation({
 *   variables: {
 *      dish: // value for 'dish'
 *      dishSource: // value for 'dishSource'
 *      dishSourceRelationDetail: // value for 'dishSourceRelationDetail'
 *      dishTags: // value for 'dishTags'
 *   },
 * });
 */
export function useAddDishWithNewSourceMutation(baseOptions?: Apollo.MutationHookOptions<AddDishWithNewSourceMutation, AddDishWithNewSourceMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<AddDishWithNewSourceMutation, AddDishWithNewSourceMutationVariables>(AddDishWithNewSourceDocument, options);
      }
export type AddDishWithNewSourceMutationHookResult = ReturnType<typeof useAddDishWithNewSourceMutation>;
export type AddDishWithNewSourceMutationResult = Apollo.MutationResult<AddDishWithNewSourceMutation>;
export type AddDishWithNewSourceMutationOptions = Apollo.BaseMutationOptions<AddDishWithNewSourceMutation, AddDishWithNewSourceMutationVariables>;
export const ExistingDishesForRegisteringWithMealDocument = gql`
    query existingDishesForRegisteringWithMeal($dishIdRegisteredWithMeal: Int, $searchString: String, $mealPosition: Int, $registeredWithMeal: Boolean) {
  existingDishesForRegisteringWithMeal(
    dishIdRegisteredWithMeal: $dishIdRegisteredWithMeal
    searchString: $searchString
    mealPosition: $mealPosition
    registeredWithMeal: $registeredWithMeal
  ) {
    id
    name
    mealPosition
    comment
    dishSourceName
  }
}
    `;

/**
 * __useExistingDishesForRegisteringWithMealQuery__
 *
 * To run a query within a React component, call `useExistingDishesForRegisteringWithMealQuery` and pass it any options that fit your needs.
 * When your component renders, `useExistingDishesForRegisteringWithMealQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useExistingDishesForRegisteringWithMealQuery({
 *   variables: {
 *      dishIdRegisteredWithMeal: // value for 'dishIdRegisteredWithMeal'
 *      searchString: // value for 'searchString'
 *      mealPosition: // value for 'mealPosition'
 *      registeredWithMeal: // value for 'registeredWithMeal'
 *   },
 * });
 */
export function useExistingDishesForRegisteringWithMealQuery(baseOptions?: Apollo.QueryHookOptions<ExistingDishesForRegisteringWithMealQuery, ExistingDishesForRegisteringWithMealQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ExistingDishesForRegisteringWithMealQuery, ExistingDishesForRegisteringWithMealQueryVariables>(ExistingDishesForRegisteringWithMealDocument, options);
      }
export function useExistingDishesForRegisteringWithMealLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ExistingDishesForRegisteringWithMealQuery, ExistingDishesForRegisteringWithMealQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ExistingDishesForRegisteringWithMealQuery, ExistingDishesForRegisteringWithMealQueryVariables>(ExistingDishesForRegisteringWithMealDocument, options);
        }
export function useExistingDishesForRegisteringWithMealSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<ExistingDishesForRegisteringWithMealQuery, ExistingDishesForRegisteringWithMealQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<ExistingDishesForRegisteringWithMealQuery, ExistingDishesForRegisteringWithMealQueryVariables>(ExistingDishesForRegisteringWithMealDocument, options);
        }
export type ExistingDishesForRegisteringWithMealQueryHookResult = ReturnType<typeof useExistingDishesForRegisteringWithMealQuery>;
export type ExistingDishesForRegisteringWithMealLazyQueryHookResult = ReturnType<typeof useExistingDishesForRegisteringWithMealLazyQuery>;
export type ExistingDishesForRegisteringWithMealSuspenseQueryHookResult = ReturnType<typeof useExistingDishesForRegisteringWithMealSuspenseQuery>;
export type ExistingDishesForRegisteringWithMealQueryResult = Apollo.QueryResult<ExistingDishesForRegisteringWithMealQuery, ExistingDishesForRegisteringWithMealQueryVariables>;
export const DishDocument = gql`
    query dish($id: Int!) {
  dish(id: $id) {
    id
    name
    mealPosition
    comment
    dishSourceRelation {
      dishSourceId
      recipeBookPage
      recipeWebsiteUrl
      recipeSourceMemo
    }
    tags {
      id
      content
    }
  }
}
    `;

/**
 * __useDishQuery__
 *
 * To run a query within a React component, call `useDishQuery` and pass it any options that fit your needs.
 * When your component renders, `useDishQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useDishQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useDishQuery(baseOptions: Apollo.QueryHookOptions<DishQuery, DishQueryVariables> & ({ variables: DishQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<DishQuery, DishQueryVariables>(DishDocument, options);
      }
export function useDishLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<DishQuery, DishQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<DishQuery, DishQueryVariables>(DishDocument, options);
        }
export function useDishSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<DishQuery, DishQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<DishQuery, DishQueryVariables>(DishDocument, options);
        }
export type DishQueryHookResult = ReturnType<typeof useDishQuery>;
export type DishLazyQueryHookResult = ReturnType<typeof useDishLazyQuery>;
export type DishSuspenseQueryHookResult = ReturnType<typeof useDishSuspenseQuery>;
export type DishQueryResult = Apollo.QueryResult<DishQuery, DishQueryVariables>;
export const DishesPerSourceDocument = gql`
    query dishesPerSource {
  dishesPerSource {
    dishSource {
      id
      name
      type
    }
    dishesPerMealPosition {
      mealPosition
      dishes {
        id
        name
        mealPosition
        comment
        meals {
          id
        }
      }
    }
  }
}
    `;

/**
 * __useDishesPerSourceQuery__
 *
 * To run a query within a React component, call `useDishesPerSourceQuery` and pass it any options that fit your needs.
 * When your component renders, `useDishesPerSourceQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useDishesPerSourceQuery({
 *   variables: {
 *   },
 * });
 */
export function useDishesPerSourceQuery(baseOptions?: Apollo.QueryHookOptions<DishesPerSourceQuery, DishesPerSourceQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<DishesPerSourceQuery, DishesPerSourceQueryVariables>(DishesPerSourceDocument, options);
      }
export function useDishesPerSourceLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<DishesPerSourceQuery, DishesPerSourceQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<DishesPerSourceQuery, DishesPerSourceQueryVariables>(DishesPerSourceDocument, options);
        }
export function useDishesPerSourceSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<DishesPerSourceQuery, DishesPerSourceQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<DishesPerSourceQuery, DishesPerSourceQueryVariables>(DishesPerSourceDocument, options);
        }
export type DishesPerSourceQueryHookResult = ReturnType<typeof useDishesPerSourceQuery>;
export type DishesPerSourceLazyQueryHookResult = ReturnType<typeof useDishesPerSourceLazyQuery>;
export type DishesPerSourceSuspenseQueryHookResult = ReturnType<typeof useDishesPerSourceSuspenseQuery>;
export type DishesPerSourceQueryResult = Apollo.QueryResult<DishesPerSourceQuery, DishesPerSourceQueryVariables>;
export const RemoveDishDocument = gql`
    mutation removeDish($dishId: Int!) {
  removeDish(input: {dishId: $dishId}) {
    dishId
  }
}
    `;
export type RemoveDishMutationFn = Apollo.MutationFunction<RemoveDishMutation, RemoveDishMutationVariables>;

/**
 * __useRemoveDishMutation__
 *
 * To run a mutation, you first call `useRemoveDishMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useRemoveDishMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [removeDishMutation, { data, loading, error }] = useRemoveDishMutation({
 *   variables: {
 *      dishId: // value for 'dishId'
 *   },
 * });
 */
export function useRemoveDishMutation(baseOptions?: Apollo.MutationHookOptions<RemoveDishMutation, RemoveDishMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<RemoveDishMutation, RemoveDishMutationVariables>(RemoveDishDocument, options);
      }
export type RemoveDishMutationHookResult = ReturnType<typeof useRemoveDishMutation>;
export type RemoveDishMutationResult = Apollo.MutationResult<RemoveDishMutation>;
export type RemoveDishMutationOptions = Apollo.BaseMutationOptions<RemoveDishMutation, RemoveDishMutationVariables>;
export const AddDishSourceDocument = gql`
    mutation addDishSource($dishSource: SourceForCreate!) {
  addDishSource(input: {dishSource: $dishSource}) {
    dishSourceId
  }
}
    `;
export type AddDishSourceMutationFn = Apollo.MutationFunction<AddDishSourceMutation, AddDishSourceMutationVariables>;

/**
 * __useAddDishSourceMutation__
 *
 * To run a mutation, you first call `useAddDishSourceMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useAddDishSourceMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [addDishSourceMutation, { data, loading, error }] = useAddDishSourceMutation({
 *   variables: {
 *      dishSource: // value for 'dishSource'
 *   },
 * });
 */
export function useAddDishSourceMutation(baseOptions?: Apollo.MutationHookOptions<AddDishSourceMutation, AddDishSourceMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<AddDishSourceMutation, AddDishSourceMutationVariables>(AddDishSourceDocument, options);
      }
export type AddDishSourceMutationHookResult = ReturnType<typeof useAddDishSourceMutation>;
export type AddDishSourceMutationResult = Apollo.MutationResult<AddDishSourceMutation>;
export type AddDishSourceMutationOptions = Apollo.BaseMutationOptions<AddDishSourceMutation, AddDishSourceMutationVariables>;
export const DishSourcesDocument = gql`
    query dishSources {
  dishSources {
    id
    name
    type
  }
}
    `;

/**
 * __useDishSourcesQuery__
 *
 * To run a query within a React component, call `useDishSourcesQuery` and pass it any options that fit your needs.
 * When your component renders, `useDishSourcesQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useDishSourcesQuery({
 *   variables: {
 *   },
 * });
 */
export function useDishSourcesQuery(baseOptions?: Apollo.QueryHookOptions<DishSourcesQuery, DishSourcesQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<DishSourcesQuery, DishSourcesQueryVariables>(DishSourcesDocument, options);
      }
export function useDishSourcesLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<DishSourcesQuery, DishSourcesQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<DishSourcesQuery, DishSourcesQueryVariables>(DishSourcesDocument, options);
        }
export function useDishSourcesSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<DishSourcesQuery, DishSourcesQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<DishSourcesQuery, DishSourcesQueryVariables>(DishSourcesDocument, options);
        }
export type DishSourcesQueryHookResult = ReturnType<typeof useDishSourcesQuery>;
export type DishSourcesLazyQueryHookResult = ReturnType<typeof useDishSourcesLazyQuery>;
export type DishSourcesSuspenseQueryHookResult = ReturnType<typeof useDishSourcesSuspenseQuery>;
export type DishSourcesQueryResult = Apollo.QueryResult<DishSourcesQuery, DishSourcesQueryVariables>;
export const DishSourceDocument = gql`
    query dishSource($id: Int!) {
  dishSource(id: $id) {
    id
    name
    type
  }
}
    `;

/**
 * __useDishSourceQuery__
 *
 * To run a query within a React component, call `useDishSourceQuery` and pass it any options that fit your needs.
 * When your component renders, `useDishSourceQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useDishSourceQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useDishSourceQuery(baseOptions: Apollo.QueryHookOptions<DishSourceQuery, DishSourceQueryVariables> & ({ variables: DishSourceQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<DishSourceQuery, DishSourceQueryVariables>(DishSourceDocument, options);
      }
export function useDishSourceLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<DishSourceQuery, DishSourceQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<DishSourceQuery, DishSourceQueryVariables>(DishSourceDocument, options);
        }
export function useDishSourceSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<DishSourceQuery, DishSourceQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<DishSourceQuery, DishSourceQueryVariables>(DishSourceDocument, options);
        }
export type DishSourceQueryHookResult = ReturnType<typeof useDishSourceQuery>;
export type DishSourceLazyQueryHookResult = ReturnType<typeof useDishSourceLazyQuery>;
export type DishSourceSuspenseQueryHookResult = ReturnType<typeof useDishSourceSuspenseQuery>;
export type DishSourceQueryResult = Apollo.QueryResult<DishSourceQuery, DishSourceQueryVariables>;
export const RemoveDishSourceDocument = gql`
    mutation removeDishSource($dishSourceId: Int!) {
  removeDishSource(input: {dishSourceId: $dishSourceId}) {
    dishSourceId
  }
}
    `;
export type RemoveDishSourceMutationFn = Apollo.MutationFunction<RemoveDishSourceMutation, RemoveDishSourceMutationVariables>;

/**
 * __useRemoveDishSourceMutation__
 *
 * To run a mutation, you first call `useRemoveDishSourceMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useRemoveDishSourceMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [removeDishSourceMutation, { data, loading, error }] = useRemoveDishSourceMutation({
 *   variables: {
 *      dishSourceId: // value for 'dishSourceId'
 *   },
 * });
 */
export function useRemoveDishSourceMutation(baseOptions?: Apollo.MutationHookOptions<RemoveDishSourceMutation, RemoveDishSourceMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<RemoveDishSourceMutation, RemoveDishSourceMutationVariables>(RemoveDishSourceDocument, options);
      }
export type RemoveDishSourceMutationHookResult = ReturnType<typeof useRemoveDishSourceMutation>;
export type RemoveDishSourceMutationResult = Apollo.MutationResult<RemoveDishSourceMutation>;
export type RemoveDishSourceMutationOptions = Apollo.BaseMutationOptions<RemoveDishSourceMutation, RemoveDishSourceMutationVariables>;
export const UpdateDishSourceDocument = gql`
    mutation updateDishSource($dishSource: SourceForUpdate!) {
  updateDishSource(input: {dishSource: $dishSource}) {
    dishSourceId
  }
}
    `;
export type UpdateDishSourceMutationFn = Apollo.MutationFunction<UpdateDishSourceMutation, UpdateDishSourceMutationVariables>;

/**
 * __useUpdateDishSourceMutation__
 *
 * To run a mutation, you first call `useUpdateDishSourceMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateDishSourceMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateDishSourceMutation, { data, loading, error }] = useUpdateDishSourceMutation({
 *   variables: {
 *      dishSource: // value for 'dishSource'
 *   },
 * });
 */
export function useUpdateDishSourceMutation(baseOptions?: Apollo.MutationHookOptions<UpdateDishSourceMutation, UpdateDishSourceMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateDishSourceMutation, UpdateDishSourceMutationVariables>(UpdateDishSourceDocument, options);
      }
export type UpdateDishSourceMutationHookResult = ReturnType<typeof useUpdateDishSourceMutation>;
export type UpdateDishSourceMutationResult = Apollo.MutationResult<UpdateDishSourceMutation>;
export type UpdateDishSourceMutationOptions = Apollo.BaseMutationOptions<UpdateDishSourceMutation, UpdateDishSourceMutationVariables>;
export const UpdateDishDocument = gql`
    mutation updateDish($dish: DishForUpdate!, $dishSourceRelation: DishSourceRelationForUpdate, $dishTags: [Tag!]) {
  updateDish(
    input: {dish: $dish, dishSourceRelation: $dishSourceRelation, dishTags: $dishTags}
  ) {
    dishId
  }
}
    `;
export type UpdateDishMutationFn = Apollo.MutationFunction<UpdateDishMutation, UpdateDishMutationVariables>;

/**
 * __useUpdateDishMutation__
 *
 * To run a mutation, you first call `useUpdateDishMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateDishMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateDishMutation, { data, loading, error }] = useUpdateDishMutation({
 *   variables: {
 *      dish: // value for 'dish'
 *      dishSourceRelation: // value for 'dishSourceRelation'
 *      dishTags: // value for 'dishTags'
 *   },
 * });
 */
export function useUpdateDishMutation(baseOptions?: Apollo.MutationHookOptions<UpdateDishMutation, UpdateDishMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateDishMutation, UpdateDishMutationVariables>(UpdateDishDocument, options);
      }
export type UpdateDishMutationHookResult = ReturnType<typeof useUpdateDishMutation>;
export type UpdateDishMutationResult = Apollo.MutationResult<UpdateDishMutation>;
export type UpdateDishMutationOptions = Apollo.BaseMutationOptions<UpdateDishMutation, UpdateDishMutationVariables>;
export const UpdateDishWithNewSourceDocument = gql`
    mutation updateDishWithNewSource($dish: DishForUpdate!, $dishSource: SourceForCreate!, $dishSourceRelationDetail: DishSourceRelationDetail, $dishTags: [Tag!]) {
  updateDishWithNewSource(
    input: {dish: $dish, dishSource: $dishSource, dishSourceRelationDetail: $dishSourceRelationDetail, dishTags: $dishTags}
  ) {
    dishId
  }
}
    `;
export type UpdateDishWithNewSourceMutationFn = Apollo.MutationFunction<UpdateDishWithNewSourceMutation, UpdateDishWithNewSourceMutationVariables>;

/**
 * __useUpdateDishWithNewSourceMutation__
 *
 * To run a mutation, you first call `useUpdateDishWithNewSourceMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateDishWithNewSourceMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateDishWithNewSourceMutation, { data, loading, error }] = useUpdateDishWithNewSourceMutation({
 *   variables: {
 *      dish: // value for 'dish'
 *      dishSource: // value for 'dishSource'
 *      dishSourceRelationDetail: // value for 'dishSourceRelationDetail'
 *      dishTags: // value for 'dishTags'
 *   },
 * });
 */
export function useUpdateDishWithNewSourceMutation(baseOptions?: Apollo.MutationHookOptions<UpdateDishWithNewSourceMutation, UpdateDishWithNewSourceMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateDishWithNewSourceMutation, UpdateDishWithNewSourceMutationVariables>(UpdateDishWithNewSourceDocument, options);
      }
export type UpdateDishWithNewSourceMutationHookResult = ReturnType<typeof useUpdateDishWithNewSourceMutation>;
export type UpdateDishWithNewSourceMutationResult = Apollo.MutationResult<UpdateDishWithNewSourceMutation>;
export type UpdateDishWithNewSourceMutationOptions = Apollo.BaseMutationOptions<UpdateDishWithNewSourceMutation, UpdateDishWithNewSourceMutationVariables>;
export const EvaluateDishDocument = gql`
    mutation evaluateDish($dishId: Int!, $score: Float!) {
  evaluateDish(input: {dishId: $dishId, score: $score}) {
    dishId
  }
}
    `;
export type EvaluateDishMutationFn = Apollo.MutationFunction<EvaluateDishMutation, EvaluateDishMutationVariables>;

/**
 * __useEvaluateDishMutation__
 *
 * To run a mutation, you first call `useEvaluateDishMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useEvaluateDishMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [evaluateDishMutation, { data, loading, error }] = useEvaluateDishMutation({
 *   variables: {
 *      dishId: // value for 'dishId'
 *      score: // value for 'score'
 *   },
 * });
 */
export function useEvaluateDishMutation(baseOptions?: Apollo.MutationHookOptions<EvaluateDishMutation, EvaluateDishMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<EvaluateDishMutation, EvaluateDishMutationVariables>(EvaluateDishDocument, options);
      }
export type EvaluateDishMutationHookResult = ReturnType<typeof useEvaluateDishMutation>;
export type EvaluateDishMutationResult = Apollo.MutationResult<EvaluateDishMutation>;
export type EvaluateDishMutationOptions = Apollo.BaseMutationOptions<EvaluateDishMutation, EvaluateDishMutationVariables>;
export const AddMealDocument = gql`
    mutation addMeal($dishId: Int!, $meal: MealForCreate!) {
  addMeal(input: {dishId: $dishId, meal: $meal}) {
    mealId
  }
}
    `;
export type AddMealMutationFn = Apollo.MutationFunction<AddMealMutation, AddMealMutationVariables>;

/**
 * __useAddMealMutation__
 *
 * To run a mutation, you first call `useAddMealMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useAddMealMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [addMealMutation, { data, loading, error }] = useAddMealMutation({
 *   variables: {
 *      dishId: // value for 'dishId'
 *      meal: // value for 'meal'
 *   },
 * });
 */
export function useAddMealMutation(baseOptions?: Apollo.MutationHookOptions<AddMealMutation, AddMealMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<AddMealMutation, AddMealMutationVariables>(AddMealDocument, options);
      }
export type AddMealMutationHookResult = ReturnType<typeof useAddMealMutation>;
export type AddMealMutationResult = Apollo.MutationResult<AddMealMutation>;
export type AddMealMutationOptions = Apollo.BaseMutationOptions<AddMealMutation, AddMealMutationVariables>;
export const AddMealWithNewDishDocument = gql`
    mutation addMealWithNewDish($dish: DishForCreate!, $dishSource: SourceForRead, $dishSourceRelationDetail: DishSourceRelationDetail, $dishTags: [Tag!], $meal: MealForCreate!) {
  addMealWithNewDish(
    input: {dish: $dish, dishSource: $dishSource, dishSourceRelationDetail: $dishSourceRelationDetail, dishTags: $dishTags, meal: $meal}
  ) {
    mealId
    dishId
  }
}
    `;
export type AddMealWithNewDishMutationFn = Apollo.MutationFunction<AddMealWithNewDishMutation, AddMealWithNewDishMutationVariables>;

/**
 * __useAddMealWithNewDishMutation__
 *
 * To run a mutation, you first call `useAddMealWithNewDishMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useAddMealWithNewDishMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [addMealWithNewDishMutation, { data, loading, error }] = useAddMealWithNewDishMutation({
 *   variables: {
 *      dish: // value for 'dish'
 *      dishSource: // value for 'dishSource'
 *      dishSourceRelationDetail: // value for 'dishSourceRelationDetail'
 *      dishTags: // value for 'dishTags'
 *      meal: // value for 'meal'
 *   },
 * });
 */
export function useAddMealWithNewDishMutation(baseOptions?: Apollo.MutationHookOptions<AddMealWithNewDishMutation, AddMealWithNewDishMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<AddMealWithNewDishMutation, AddMealWithNewDishMutationVariables>(AddMealWithNewDishDocument, options);
      }
export type AddMealWithNewDishMutationHookResult = ReturnType<typeof useAddMealWithNewDishMutation>;
export type AddMealWithNewDishMutationResult = Apollo.MutationResult<AddMealWithNewDishMutation>;
export type AddMealWithNewDishMutationOptions = Apollo.BaseMutationOptions<AddMealWithNewDishMutation, AddMealWithNewDishMutationVariables>;
export const AddMealWithNewDishAndNewSourceDocument = gql`
    mutation addMealWithNewDishAndNewSource($dish: DishForCreate!, $dishSource: SourceForCreate!, $dishSourceRelationDetail: DishSourceRelationDetail, $dishTags: [Tag!], $meal: MealForCreate!) {
  addMealWithNewDishAndNewSource(
    input: {dish: $dish, dishSource: $dishSource, dishSourceRelationDetail: $dishSourceRelationDetail, dishTags: $dishTags, meal: $meal}
  ) {
    mealId
    dishId
    dishSourceId
  }
}
    `;
export type AddMealWithNewDishAndNewSourceMutationFn = Apollo.MutationFunction<AddMealWithNewDishAndNewSourceMutation, AddMealWithNewDishAndNewSourceMutationVariables>;

/**
 * __useAddMealWithNewDishAndNewSourceMutation__
 *
 * To run a mutation, you first call `useAddMealWithNewDishAndNewSourceMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useAddMealWithNewDishAndNewSourceMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [addMealWithNewDishAndNewSourceMutation, { data, loading, error }] = useAddMealWithNewDishAndNewSourceMutation({
 *   variables: {
 *      dish: // value for 'dish'
 *      dishSource: // value for 'dishSource'
 *      dishSourceRelationDetail: // value for 'dishSourceRelationDetail'
 *      dishTags: // value for 'dishTags'
 *      meal: // value for 'meal'
 *   },
 * });
 */
export function useAddMealWithNewDishAndNewSourceMutation(baseOptions?: Apollo.MutationHookOptions<AddMealWithNewDishAndNewSourceMutation, AddMealWithNewDishAndNewSourceMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<AddMealWithNewDishAndNewSourceMutation, AddMealWithNewDishAndNewSourceMutationVariables>(AddMealWithNewDishAndNewSourceDocument, options);
      }
export type AddMealWithNewDishAndNewSourceMutationHookResult = ReturnType<typeof useAddMealWithNewDishAndNewSourceMutation>;
export type AddMealWithNewDishAndNewSourceMutationResult = Apollo.MutationResult<AddMealWithNewDishAndNewSourceMutation>;
export type AddMealWithNewDishAndNewSourceMutationOptions = Apollo.BaseMutationOptions<AddMealWithNewDishAndNewSourceMutation, AddMealWithNewDishAndNewSourceMutationVariables>;
export const MealsForCalenderDocument = gql`
    query mealsForCalender($startDate: ISO8601Date!) {
  mealsForCalender(startDate: $startDate) {
    date
    meals {
      id
      date
      mealType
      comment
      dish {
        id
        name
        mealPosition
        comment
        evaluationScore
        dishSourceRelation {
          type
          sourceName
          dishSourceId
          recipeBookPage
          recipeWebsiteUrl
          recipeSourceMemo
        }
        tags {
          id
          dishId
          content
        }
      }
    }
  }
}
    `;

/**
 * __useMealsForCalenderQuery__
 *
 * To run a query within a React component, call `useMealsForCalenderQuery` and pass it any options that fit your needs.
 * When your component renders, `useMealsForCalenderQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useMealsForCalenderQuery({
 *   variables: {
 *      startDate: // value for 'startDate'
 *   },
 * });
 */
export function useMealsForCalenderQuery(baseOptions: Apollo.QueryHookOptions<MealsForCalenderQuery, MealsForCalenderQueryVariables> & ({ variables: MealsForCalenderQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<MealsForCalenderQuery, MealsForCalenderQueryVariables>(MealsForCalenderDocument, options);
      }
export function useMealsForCalenderLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<MealsForCalenderQuery, MealsForCalenderQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<MealsForCalenderQuery, MealsForCalenderQueryVariables>(MealsForCalenderDocument, options);
        }
export function useMealsForCalenderSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<MealsForCalenderQuery, MealsForCalenderQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<MealsForCalenderQuery, MealsForCalenderQueryVariables>(MealsForCalenderDocument, options);
        }
export type MealsForCalenderQueryHookResult = ReturnType<typeof useMealsForCalenderQuery>;
export type MealsForCalenderLazyQueryHookResult = ReturnType<typeof useMealsForCalenderLazyQuery>;
export type MealsForCalenderSuspenseQueryHookResult = ReturnType<typeof useMealsForCalenderSuspenseQuery>;
export type MealsForCalenderQueryResult = Apollo.QueryResult<MealsForCalenderQuery, MealsForCalenderQueryVariables>;
export const RemoveMealDocument = gql`
    mutation removeMeal($mealId: Int!) {
  removeMeal(input: {mealId: $mealId}) {
    mealId
  }
}
    `;
export type RemoveMealMutationFn = Apollo.MutationFunction<RemoveMealMutation, RemoveMealMutationVariables>;

/**
 * __useRemoveMealMutation__
 *
 * To run a mutation, you first call `useRemoveMealMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useRemoveMealMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [removeMealMutation, { data, loading, error }] = useRemoveMealMutation({
 *   variables: {
 *      mealId: // value for 'mealId'
 *   },
 * });
 */
export function useRemoveMealMutation(baseOptions?: Apollo.MutationHookOptions<RemoveMealMutation, RemoveMealMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<RemoveMealMutation, RemoveMealMutationVariables>(RemoveMealDocument, options);
      }
export type RemoveMealMutationHookResult = ReturnType<typeof useRemoveMealMutation>;
export type RemoveMealMutationResult = Apollo.MutationResult<RemoveMealMutation>;
export type RemoveMealMutationOptions = Apollo.BaseMutationOptions<RemoveMealMutation, RemoveMealMutationVariables>;
export const SwapMealsBetweenDaysDocument = gql`
    mutation swapMealsBetweenDays($date1: ISO8601Date!, $date2: ISO8601Date!) {
  swapMealsBetweenDays(input: {date1: $date1, date2: $date2}) {
    updatedMealIds
  }
}
    `;
export type SwapMealsBetweenDaysMutationFn = Apollo.MutationFunction<SwapMealsBetweenDaysMutation, SwapMealsBetweenDaysMutationVariables>;

/**
 * __useSwapMealsBetweenDaysMutation__
 *
 * To run a mutation, you first call `useSwapMealsBetweenDaysMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useSwapMealsBetweenDaysMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [swapMealsBetweenDaysMutation, { data, loading, error }] = useSwapMealsBetweenDaysMutation({
 *   variables: {
 *      date1: // value for 'date1'
 *      date2: // value for 'date2'
 *   },
 * });
 */
export function useSwapMealsBetweenDaysMutation(baseOptions?: Apollo.MutationHookOptions<SwapMealsBetweenDaysMutation, SwapMealsBetweenDaysMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<SwapMealsBetweenDaysMutation, SwapMealsBetweenDaysMutationVariables>(SwapMealsBetweenDaysDocument, options);
      }
export type SwapMealsBetweenDaysMutationHookResult = ReturnType<typeof useSwapMealsBetweenDaysMutation>;
export type SwapMealsBetweenDaysMutationResult = Apollo.MutationResult<SwapMealsBetweenDaysMutation>;
export type SwapMealsBetweenDaysMutationOptions = Apollo.BaseMutationOptions<SwapMealsBetweenDaysMutation, SwapMealsBetweenDaysMutationVariables>;
export const UpdateMealDocument = gql`
    mutation updateMeal($dishId: Int!, $meal: MealForUpdate!) {
  updateMeal(input: {dishId: $dishId, meal: $meal}) {
    mealId
  }
}
    `;
export type UpdateMealMutationFn = Apollo.MutationFunction<UpdateMealMutation, UpdateMealMutationVariables>;

/**
 * __useUpdateMealMutation__
 *
 * To run a mutation, you first call `useUpdateMealMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateMealMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateMealMutation, { data, loading, error }] = useUpdateMealMutation({
 *   variables: {
 *      dishId: // value for 'dishId'
 *      meal: // value for 'meal'
 *   },
 * });
 */
export function useUpdateMealMutation(baseOptions?: Apollo.MutationHookOptions<UpdateMealMutation, UpdateMealMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateMealMutation, UpdateMealMutationVariables>(UpdateMealDocument, options);
      }
export type UpdateMealMutationHookResult = ReturnType<typeof useUpdateMealMutation>;
export type UpdateMealMutationResult = Apollo.MutationResult<UpdateMealMutation>;
export type UpdateMealMutationOptions = Apollo.BaseMutationOptions<UpdateMealMutation, UpdateMealMutationVariables>;
export const UpdateMealWithNewDishDocument = gql`
    mutation updateMealWithNewDish($dish: DishForCreate!, $dishSource: SourceForRead!, $dishSourceRelationDetail: DishSourceRelationDetail, $dishTags: [Tag!], $meal: MealForUpdate!) {
  updateMealWithNewDish(
    input: {dish: $dish, dishSource: $dishSource, dishSourceRelationDetail: $dishSourceRelationDetail, dishTags: $dishTags, meal: $meal}
  ) {
    mealId
    dishId
  }
}
    `;
export type UpdateMealWithNewDishMutationFn = Apollo.MutationFunction<UpdateMealWithNewDishMutation, UpdateMealWithNewDishMutationVariables>;

/**
 * __useUpdateMealWithNewDishMutation__
 *
 * To run a mutation, you first call `useUpdateMealWithNewDishMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateMealWithNewDishMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateMealWithNewDishMutation, { data, loading, error }] = useUpdateMealWithNewDishMutation({
 *   variables: {
 *      dish: // value for 'dish'
 *      dishSource: // value for 'dishSource'
 *      dishSourceRelationDetail: // value for 'dishSourceRelationDetail'
 *      dishTags: // value for 'dishTags'
 *      meal: // value for 'meal'
 *   },
 * });
 */
export function useUpdateMealWithNewDishMutation(baseOptions?: Apollo.MutationHookOptions<UpdateMealWithNewDishMutation, UpdateMealWithNewDishMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateMealWithNewDishMutation, UpdateMealWithNewDishMutationVariables>(UpdateMealWithNewDishDocument, options);
      }
export type UpdateMealWithNewDishMutationHookResult = ReturnType<typeof useUpdateMealWithNewDishMutation>;
export type UpdateMealWithNewDishMutationResult = Apollo.MutationResult<UpdateMealWithNewDishMutation>;
export type UpdateMealWithNewDishMutationOptions = Apollo.BaseMutationOptions<UpdateMealWithNewDishMutation, UpdateMealWithNewDishMutationVariables>;
export const UpdateMealWithNewDishAndNewSourceDocument = gql`
    mutation updateMealWithNewDishAndNewSource($dish: DishForCreate!, $dishSource: SourceForCreate!, $dishSourceRelationDetail: DishSourceRelationDetail, $dishTags: [Tag!], $meal: MealForUpdate!) {
  updateMealWithNewDishAndNewSource(
    input: {dish: $dish, dishSource: $dishSource, dishSourceRelationDetail: $dishSourceRelationDetail, dishTags: $dishTags, meal: $meal}
  ) {
    mealId
    dishId
    dishSourceId
  }
}
    `;
export type UpdateMealWithNewDishAndNewSourceMutationFn = Apollo.MutationFunction<UpdateMealWithNewDishAndNewSourceMutation, UpdateMealWithNewDishAndNewSourceMutationVariables>;

/**
 * __useUpdateMealWithNewDishAndNewSourceMutation__
 *
 * To run a mutation, you first call `useUpdateMealWithNewDishAndNewSourceMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateMealWithNewDishAndNewSourceMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateMealWithNewDishAndNewSourceMutation, { data, loading, error }] = useUpdateMealWithNewDishAndNewSourceMutation({
 *   variables: {
 *      dish: // value for 'dish'
 *      dishSource: // value for 'dishSource'
 *      dishSourceRelationDetail: // value for 'dishSourceRelationDetail'
 *      dishTags: // value for 'dishTags'
 *      meal: // value for 'meal'
 *   },
 * });
 */
export function useUpdateMealWithNewDishAndNewSourceMutation(baseOptions?: Apollo.MutationHookOptions<UpdateMealWithNewDishAndNewSourceMutation, UpdateMealWithNewDishAndNewSourceMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateMealWithNewDishAndNewSourceMutation, UpdateMealWithNewDishAndNewSourceMutationVariables>(UpdateMealWithNewDishAndNewSourceDocument, options);
      }
export type UpdateMealWithNewDishAndNewSourceMutationHookResult = ReturnType<typeof useUpdateMealWithNewDishAndNewSourceMutation>;
export type UpdateMealWithNewDishAndNewSourceMutationResult = Apollo.MutationResult<UpdateMealWithNewDishAndNewSourceMutation>;
export type UpdateMealWithNewDishAndNewSourceMutationOptions = Apollo.BaseMutationOptions<UpdateMealWithNewDishAndNewSourceMutation, UpdateMealWithNewDishAndNewSourceMutationVariables>;